## 헤드퍼스트 팩토리 메서드 패턴


구현 클래스를 바탕으로 코딩을 하면
1. 수정해야할 가능성이 높아지고
2. 유연성이 떨어짐

인터페이스에 맞춰 코딩하면
다형성 덕분에 어떤 클래스든 특정 인터페이스만 구현하면 사용 가능

반대로, 구현 클래스가 많으면 새로운 구현 클래스 추가 할때마다 코드를 고쳐야할 수 있음

이는 OCP 원칙에 어긋남


SimplePizzaFactory를 사용하는 것처럼, 간단한 팩토리는 디자인 패턴이 아니다.

**주의**

"인터페이스를 구현한다."

-> 항상 클래스 선언 부에서 implements 키워드를 써서 어떤 자바 인터페이스를 구현하는 클래스를 만든다. (X)

-> 어떤 상위(클래스 일 수도 있고, 인터페이스 일 수 도 있음)에 있는 메소드를 구현하는 구상 클래스는
    그 상위 형식의 "인터페이스를 구현하는 " 클래스라고 생각하면 된다.


**문제 발생**

* 뉴욕지점과 시카고 피자 가게에서 우리가 만든 팩토리를 쓰지만, 독자적으로 이상하게 피자를 만들기 시작함.
-> 피자 가게와 피자 제작 과정을 하나로 묶어야겠다!

1. createPizza() 메서드 PizzaStore에 다시 추가
2. createPizza() 메서드 추상메서드 선언
3. PizzaStore의 서브 클래스 생성되는 형태로 변경


-> PizzaStore의
    * orderPizza() -> 모든 분점에서 똑같이 진행 :: PizzaStore에 정의했던 그대로 사용
    * createPizza() -> 분점에서 각자 스타일에 맞게 구현 하는 형태로 변경 -> 각 분점 클래스에서 createPizza() 오버라이드해서 사용



**질문**

### Q. PizzaStore의 서브 클래스 NYPizzaStore에서 무슨 결정을 내리냐?
* A. 우리가 선택한 PizzaStore의 서브클래스 종류에 따라 결정되지만, 어떤 스타일의 피자가 만들어질지는 NYPizzaStore가 결정합니다.

- PizzaStore과 Pizza의 분리
  - orderPizza() 메서드에서 Pizza 객체를 가지고 여러 작업을 하지만, 어떤 PizzaStore에서 하는지는 알수 없음


**팩토리 메서드**
* 팩토리 메서드는 객체 생성을 처리
* 팩토리 메서드를 이용하면, 객체 생성하는 작업을 서브클래스에 캡슐화 시킬 수 있음
* 이렇게 하면, 수퍼클래스 클라이언트 코드와 서브 클래스의 객체 생성 코드 분리 가능



