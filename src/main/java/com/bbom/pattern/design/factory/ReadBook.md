## 헤드퍼스트 팩토리 메서드 패턴


구현 클래스를 바탕으로 코딩을 하면
1. 수정해야할 가능성이 높아지고
2. 유연성이 떨어짐

인터페이스에 맞춰 코딩하면
다형성 덕분에 어떤 클래스든 특정 인터페이스만 구현하면 사용 가능

반대로, 구현 클래스가 많으면 새로운 구현 클래스 추가 할때마다 코드를 고쳐야할 수 있음

이는 OCP 원칙에 어긋남


SimplePizzaFactory를 사용하는 것처럼, 간단한 팩토리는 디자인 패턴이 아니다.

**주의**

"인터페이스를 구현한다."

-> 항상 클래스 선언 부에서 implements 키워드를 써서 어떤 자바 인터페이스를 구현하는 클래스를 만든다. (X)

-> 어떤 상위(클래스 일 수도 있고, 인터페이스 일 수 도 있음)에 있는 메소드를 구현하는 구상 클래스는
    그 상위 형식의 "인터페이스를 구현하는 " 클래스라고 생각하면 된다.


**문제 발생**

* 뉴욕지점과 시카고 피자 가게에서 우리가 만든 팩토리를 쓰지만, 독자적으로 이상하게 피자를 만들기 시작함.
-> 피자 가게와 피자 제작 과정을 하나로 묶어야겠다!

1. createPizza() 메서드 PizzaStore에 다시 추가
2. createPizza() 메서드 추상메서드 선언
3. PizzaStore의 서브 클래스 생성되는 형태로 변경


-> PizzaStore의
    * orderPizza() -> 모든 분점에서 똑같이 진행 :: PizzaStore에 정의했던 그대로 사용
    * createPizza() -> 분점에서 각자 스타일에 맞게 구현 하는 형태로 변경 -> 각 분점 클래스에서 createPizza() 오버라이드해서 사용



**질문**

### Q. PizzaStore의 서브 클래스 NYPizzaStore에서 무슨 결정을 내리냐?
* A. 우리가 선택한 PizzaStore의 서브클래스 종류에 따라 결정되지만, 어떤 스타일의 피자가 만들어질지는 NYPizzaStore가 결정합니다.

- PizzaStore과 Pizza의 분리
  - orderPizza() 메서드에서 Pizza 객체를 가지고 여러 작업을 하지만, 어떤 PizzaStore에서 하는지는 알수 없음


**팩토리 메서드**
* 팩토리 메서드는 객체 생성을 처리
* 팩토리 메서드를 이용하면, 객체 생성하는 작업을 서브클래스에 캡슐화 시킬 수 있음
* 이렇게 하면, 수퍼클래스 클라이언트 코드와 서브 클래스의 객체 생성 코드 분리 가능


**PizzaTestDrive**

* 수퍼 클래스 PizzaStore는 구현 내용을 알필요가 없습니다.
* 서브 클래스 NYPizzaStore와 ChicagoPizzaStore가 올바른 Pizza 인스턴스를 만듭니다.


## 팩토리 메소드 패턴
* 모든 팩토리 패턴에서는 객체 생성을 캡슐화 합니다.
* 팩토리 메소드 패턴에서는 서브클래스에서 어떤 클래스를 만들지를 결정하게 하고, 객체 생성을 캡슐화 합니다.
* 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의합니다.
* 어떤 클래스의 인터페이스를 만들지는 서브클래스에서 결정합니다.
-> 팩토리 메서드 패턴을 이용하면 클래스의 인스턴스를 생성하는 것을 서브클래스에 맡기는것입니다.

**병렬 클래스 계층 구조**
* 서로 다른 계층인데, 같은 구조로 대응 관계를 가지는 것을 의미
* NyPizzaStore -> NYStyle***Pizza
* ChicagoPizzaStore -> Chicago****Pizza
->  그림 그릴 줄 알지?


## 의존성 뒤집기 원칙 (Dependency Inversion Principle)
* 구상 클래스에 대한 의존성을 줄이는 것
* 추상화 된것에 의존하도록 만들기
* 고수준의 구성요소가 저수준 구성요소에 의존해서는 안된다.
  * 고수준의 구성요소
    * 다른 저수준 구성요소에 의해 정의 되는 행동이 들어있는 요소
    * PizzaStore의 행동(로직) Pizza를 만드는 것을 의미하는데
    * PizzaStore가 고수준의 구성요소
    * Pizza의 객체들이 저수준의 구성요소

    
* 객체 지향 디자인을 할 때는, 일반적으로 생각하는 방법과 반대로 뒤집어서 생각해야한다.
* 저수준의 구성요소가 고수준의 추상 클래스에 의존하는 것
* 저수준 구성 요소도 같은 추상 클래스에 연결됨
-> 고수준 모듈과 저수준 모듈이 둘다 추상 클래스에 의존하는 모습


## 의존성 뒤집기 원칙을 지킬 수 있는 가이드 라인
* 어떤 변수에도 구상 클래스의 래퍼런스를 저장하지 않기
* 구상 클래스에서 유도된 클래스 만들지 않기
* 베이스 클래스에 이미 구현된 메서도를 오버라이드 하지 않기

